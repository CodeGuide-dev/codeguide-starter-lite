-- Migration: Create AI Chat related tables and RLS policies
-- Generated by Charlie on 2025-07-30

set check_function_bodies = off;

-- Conversations table keeps high-level chat sessions
create table if not exists public.conversations (
    id uuid primary key default gen_random_uuid(),
    user_id uuid references auth.users(id) on delete cascade,
    title text,
    provider text not null,                -- e.g. 'openai' | 'anthropic'
    model text not null,                   -- e.g. 'gpt-4o'
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

alter table public.conversations enable row level security;

create policy "conversations_select" on public.conversations
    for select using (user_id::text = public.requesting_user_id());

create policy "conversations_modify" on public.conversations
    for all using (user_id::text = public.requesting_user_id()) with check (user_id::text = public.requesting_user_id());


-- Messages table stores individual chat messages
create table if not exists public.messages (
    id uuid primary key default gen_random_uuid(),
    conversation_id uuid references public.conversations(id) on delete cascade,
    role text not null,                   -- 'system' | 'user' | 'assistant' | 'tool'
    content text not null,
    token_count int,
    created_at timestamptz default now()
);

alter table public.messages enable row level security;

create policy "messages_select" on public.messages
    for select using (
        conversation_id in (
            select id from public.conversations where user_id::text = public.requesting_user_id()
        )
    );

create policy "messages_modify" on public.messages
    for all using (
        conversation_id in (
            select id from public.conversations where user_id::text = public.requesting_user_id()
        )
    ) with check (
        conversation_id in (
            select id from public.conversations where user_id::text = public.requesting_user_id()
        )
    );


-- Optional table: user-provided provider API keys (encrypted at rest)
create table if not exists public.user_api_keys (
    user_id uuid primary key references auth.users(id) on delete cascade,
    provider text not null,
    api_key_encrypted text not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

alter table public.user_api_keys enable row level security;

create policy "user_api_keys_full" on public.user_api_keys
    for all using (user_id::text = public.requesting_user_id()) with check (user_id::text = public.requesting_user_id());
